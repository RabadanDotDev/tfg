\section{Anàlisis herramientas de extracción de características}

\subsection{CICFlowmeter}

CICFlowMeter es una herramienta para generar y analizar flujos de red \cite{cicflowpost} \cite{icissp17} \cite{cicflowrepo}. Permite obtener información sobre flujos bidireccionales sobre IP, utilizan estos TCP o UDP a partir de trazas de red en archivos con el formato pcap. Por cada flujo, genera seis columnas identificativas y añade cierta información del flujo. 

\subsubsection{Features generadas}

En el Readme del código fuente ofrecido, podemos encontrar las siguientes características generadas. Hay algunas que representan lo mismo, pero se obtienen de manera distinta como "Fwd Packet Length Mean" y "Fwd Segment Size Avg".


\begin{enumerate}
    \item \textbf{Flow ID}: Combinación de las otras columnas separadas por giones
    \item \textbf{Src IP}: La dirección IP del remitente desde la cual se ha iniciado el flujo
    \item \textbf{Src Port}: La dirección IP del destinatario hacia la cual se ha dirigido el flujo
    \item \textbf{Dst IP}: El puerto origen o de retorno del remitente
    \item \textbf{Dst Port}: El puerto destino del destinatario
    \item \textbf{Protocol}: Identificador del protocolo sobre IP según definido por IANA \cite{ipprotocolnumbers}
    \item \textbf{Timestamp}: Momento del inicio del flujo, expresado en dd/MM/yyyy hh:mm:ss de la zona horaria local. En la descripción se indica que 
    \item \textbf{Flow Duration}: Duracion del flujo, expresado en microsegundos
    \item \textbf{Total Fwd Packet}: Número total de paquetes hacia el destinatario
    \item \textbf{Total Bwd packets}: Número total de paquetes hacia el receptor
    \item \textbf{Total Length of Fwd Packet}: Número completo de bytes transmitidos hacia el destinatario
    \item \textbf{Total Length of Bwd Packet}: Número completo de bytes recibidos desde el destinatario
    \item \textbf{Fwd Packet Length Max}: Tamaño en bytes del paquete más grande enviado hacia el destinatario
    \item \textbf{Fwd Packet Length Min}: Tamaño en bytes del paquete más pequeño enviado hacia el destinatario
    \item \textbf{Fwd Packet Length Mean}: Media aritmética del tamaño en bytes de los paquetes enviados hacia el destinatario. Es extraído de un objeto "SummaryStatistics" en el código
    \item \textbf{Fwd Packet Length Std}: Desviación estándar del tamaño en bytes de los paquetes enviados hacia el destinatario
    \item \textbf{Bwd Packet Length Max}: Tamaño en bytes del paquete más grande enviado hacia el emisor
    \item \textbf{Bwd Packet Length Min}: Tamaño en bytes del paquete más pequeño enviado hacia el emisor
    \item \textbf{Bwd Packet Length Mean}: Media aritmética del tamaño en bytes de los paquetes enviados hacia el emisor
    \item \textbf{Bwd Packet Length Std}: Desviación estándar del tamaño en bytes de los paquetes enviados hacia el emisor
    \item \textbf{Flow Bytes s}: Bytes por segundo del flujo
    \item \textbf{Flow Packets s}: Paquetes por segundo del flujo
    \item \textbf{Flow IAT Mean}: Media aritmética del tiempo de llegada entre paquetes
    \item \textbf{Flow IAT Std}: Desviación estándar del tiempo de llegada entre paquetes
    \item \textbf{Flow IAT Max}: Tiempo máximo de llegada entre paquetes
    \item \textbf{Flow IAT Min}: Tiempo mínimo de llegada entre paquetes
    \item \textbf{Fwd IAT Total}: Tiempo total entre la llegada de dos paquetes hacia el receptor
    \item \textbf{Fwd IAT Mean}: Media aritmética del tiempo de llegada entre paquetes hacia el receptor
    \item \textbf{Fwd IAT Std}: Desviación estándar del tiempo de llegada entre paquetes hacia el receptor
    \item \textbf{Fwd IAT Max}: Tiempo máximo de llegada entre paquetes hacia el receptor
    \item \textbf{Fwd IAT Min}: Tiempo mínimo de llegada entre paquetes hacia el receptor
    \item \textbf{Bwd IAT Total}: Tiempo total entre la llegada de dos paquetes hacia el emisor
    \item \textbf{Bwd IAT Mean}: Media aritmética del tiempo de llegada entre paquetes hacia el emisor
    \item \textbf{Bwd IAT Std}: Desviación estándar del tiempo de llegada entre paquetes hacia el emisor
    \item \textbf{Bwd IAT Max}: Tiempo máximo de llegada entre paquetes hacia el emisor
    \item \textbf{Bwd IAT Min}: Tiempo mínimo de llegada entre paquetes hacia el emisor
    \item \textbf{Fwd PSH Flags}: Número de paquetes con el flag PSH activado en la cabecera TCP hacia el emisor
    \item \textbf{Bwd PSH Flags}: Número de paquetes con el flag PSH activado en la cabecera TCP hacia el receptor
    \item \textbf{Fwd URG Flags}: Número de paquetes con el flag URG activado en la cabecera TCP hacia el emisor
    \item \textbf{Bwd URG Flags}: Número de paquetes con el flag URG activado en la cabecera TCP hacia el receptor
    \item \textbf{Fwd Header Length}: Número de paquetes con el flag PSH activado en la cabecera TCP hacia el emisor
    \item \textbf{Bwd Header Length}: Número de paquetes con el flag PSH activado en la cabecera TCP hacia el receptor
    \item \textbf{Fwd Packets s}: Paquetes por segundo hacia el receptor
    \item \textbf{Bwd Packets s}: Paquetes por segundo hacia el emisor
    \item \textbf{Packet Length Min}: Longitud en bytes del paquete más pequeño del flujo
    \item \textbf{Packet Length Max}: Longitud en bytes del paquete más grande del flujo
    \item \textbf{Packet Length Mean}: Media aritmética del tamaño de los paquetes en bytes
    \item \textbf{Packet Length Std}: Desviación estándar del tamaño de los paquetes en bytes
    \item \textbf{Packet Length Variance}: Varianza del tamaño de los paquetes en bytes
    \item \textbf{FIN Flag Count}: Número total de paquetes con el flag FIN activado en la cabecera TCP
    \item \textbf{SYN Flag Count}: Número total de paquetes con el flag SYN activado en la cabecera TCP
    \item \textbf{RST Flag Count}: Número total de paquetes con el flag RST activado en la cabecera TCP
    \item \textbf{PSH Flag Count}: Número total de paquetes con el flag PSH activado en la cabecera TCP
    \item \textbf{ACK Flag Count}: Número total de paquetes con el flag ACK activado en la cabecera TCP
    \item \textbf{URG Flag Count}: Número total de paquetes con el flag URG activado en la cabecera TCP
    \item \textbf{CWR Flag Count}: Número total de paquetes con el flag CWR activado en la cabecera TCP
    \item \textbf{ECE Flag Count}: Número total de paquetes con el flag ECE activado en la cabecera TCP
    \item \textbf{Down Up Ratio}: Ratio entre la descarga y la carga
    \item \textbf{Average Packet Size}: Media aritmética del tamaño de los paquetes
    \item \textbf{Fwd Segment Size Avg}: Media aritmética del tamaño en bytes de los paquetes enviados hacia el destinatario. Es calculado haciendo la división de la suma de los tamaños total en SummaryStatistics con el número de veces que se han acumulado valores en SummaryStatistics.
    \item \textbf{Bwd Segment Size Avg}: Media aritmética del tamaño en bytes de los paquetes enviados hacia el emisor. Es calculado haciendo la división de la suma de los tamaños total en SummaryStatistics con el número de veces que se han acumulado valores en SummaryStatistics.
    \item \textbf{Fwd Bytes Bulk Avg}: Media aritmética del número de bytes en un grupo de paquetes sin tiempo de inactividad hacia el receptor
    \item \textbf{Fwd Packet Bulk Avg}: Media aritmética del número de paquetes en un grupo de paquetes sin tiempo de inactividad hacia el receptor
    \item \textbf{Fwd Bulk Rate Avg}: Ratio de número de bytes por segundo en un grupo de paquetes sin tiempo de inactividad hacia el receptor
    \item \textbf{Bwd Bytes Bulk Avg}: Media aritmética del número de bytes en un grupo de paquetes sin tiempo de inactividad hacia el emisor
    \item \textbf{Bwd Packet Bulk Avg}: Media aritmética del número de paquetes en un grupo de paquetes sin tiempo de inactividad hacia el emisor
    \item \textbf{Bwd Bulk Rate Avg}: Ratio de número de bytes por segundo en un grupo de paquetes sin tiempo de inactividad hacia el emisor
    \item \textbf{Subflow Fwd Packets}: Número de paquetes dividido por el número de "subflujos" (espacios de más de un segundo sin paquetes) hacia el receptor
    \item \textbf{Subflow Fwd Bytes}: Número de bytes divididos por el número de "subflujos" (espacios de más de un segundo sin paquetes) hacia el receptor
    \item \textbf{Subflow Bwd Packets}: Número de bytes dividido por el número de "subflujos" (espacios de más de un segundo sin paquetes) hacia el emisor
    \item \textbf{Subflow Bwd Bytes}: Número de bytes dividido por el número de "subflujos" (espacios de más de un segundo sin paquetes) hacia el emisor
    \item \textbf{FWD Init Win Bytes}: El número total de bytes enviados en la ventana TCP inicial hacia el receptor
    \item \textbf{Bwd Init Win Bytes}: El número total de bytes enviados en la ventana TCP inicial hacia el emisor
    \item \textbf{Fwd Act Data Pkts}: El número de paquetes con al menos un byte en el campo de datos de TCP hacia el receptor
    \item \textbf{Fwd Seg Size Min}: El tamaño de segmento en bytes en la cabecera más pequeño observado hacia el receptor
    \item \textbf{Active Mean}: La media aritmética del tiempo que el flujo se ha mantenido activo antes de pasar a estar inactivo
    \item \textbf{Active Std}: La desviación estándar de tiempo que el flujo se ha mantenido activo antes de pasar a estar inactivo
    \item \textbf{Active Max}: El tiempo máximo que el flujo se ha mantenido activo antes de pasar a estar inactivo
    \item \textbf{Active Min}: El tiempo mínimo que el flujo se ha mantenido activo antes de pasar a estar inactivo
    \item \textbf{Idle Mean}: La media aritmética del tiempo que el flujo se ha mantenido inactivo antes de pasar a estar activo
    \item \textbf{Idle Std}: La desviación estándar de tiempo que el flujo se ha mantenido inactivo antes de pasar a estar activo
    \item \textbf{Idle Max}: El tiempo máximo que el flujo se ha mantenido inactivo antes de pasar a estar activo
    \item \textbf{Idle Min}: El tiempo mínimo que el flujo se ha mantenido inactivo antes de pasar a estar activo
\end{enumerate}

\subsubsection{Soporte de formatos}

CICFlowMeter no soporta todos los posibles formatos que se pueden encontrar en un pcap. En caso de encontrar contenidos no soportados, estos son ignorados. Si accedemos al módulo que realiza la lectura de los paquetes (cic.cs.unb.ca.jnetpcap.PacketReader) podemos ver que hace uso de la librería jnetpcap. Para la capa de acceso a la red en la pila TCP/IP utiliza Ethernet, para la capa de red utiliza IP4 e IP6, para la de transporte utiliza TCP y UDP y finalmente añade un módulo de la capa de aplicación para poder entender datos de VPN. 

Como veremos en INTRODUCIR REFERENCIA DATASET, necesitaríamos que tuviese soporte adicionalmente para DLT\_LINUX\_SLL. Este es un tipo especial de cabecera de nivel de acceso a la red para, entre otros, casos en los cuales se capturan trazas de diferentes orígenes.

\subsubsection{Limitantes i mejoras}

Se han observado tres puntos de mejora que la herramienta presenta, aparte de la falta de soporte para DLT\_LINUX\_SLL.

El primero consiste en que, en el momento de realizar extracción de características a partir de trazas de red, se ha observado una segunda cabecera en partes impredecibles de los archivos csv. Después de revisar el código, la causa es debido a que en el módulo cic.cs.unb.ca.jnetpcap.FlowGenerator, en la función dumpLabeledFlowBasedFeatures, se escribe la cabecera dos veces, una después de generar el archivo y otra después de escribir todos los flujos completos. No hay ninguna indicación de por qué se ha realizado de esta manera, y la línea 282 del módulo, la cual escribe la cabecera por segunda vez, tiene una indentación de dos cuando el código alrededor tiene tres. La razón más probable es que sea un error no intencional.

El segundo trata sobre la documentación del código y su calidad. La mayor parte de funciones, clases y módulos se encuentran sin documentación, hay bloques de código comentados (puestos en forma de comentario para que sean ignorados en el momento de ejecución), en muchas ocasiones la indentación es confusa y el estilo no parece ser uniforme. 

El último se basa en el lenguaje utilizado. Como podemos ver en la Tabla \ref{table:languagebench}, en muchos entornos Java no es el lenguaje más óptimo en tareas que requieran cómputo. Los programas creados en java son entre 2 y 5 veces más lentos que los creados en nim, rust, d o zig. Además de también utilizar alrededor más de diez veces la cantidad de memoria en el pico.

\begin{table}[]
    \resizebox{\textwidth}{!}{%
        \begin{tabular}{|c c c c c c c c|} 
            \hline
            \textbf{lang} & \textbf{code} & \textbf{time} & \textbf{stddev} & \textbf{peak-mem} & \textbf{time(user)} & \textbf{time(sys)} & \textbf{compiler/runtime} \\
            \hline\hline
            zig     & 1.zig   & 247ms   & 1.0ms  & 4.2MB    & 237ms      & 0ms       & zig 0.12.0-dev.2341+92211135f \\
            rust    & 9.rs    & 247ms   & 1.9ms  & 4.9MB    & 237ms      & 0ms       & rustc 1.77.0-nightly \\
            rust    & 8.rs    & 296ms   & 1.9ms  & 4.9MB    & 287ms      & 0ms       & rustc 1.75.0 \\
            d       & 1.d     & 322ms   & 1.3ms  & 7.4MB    & 310ms      & 0ms       & ldc2 1.36.0 \\
            crystal & 1.cr    & 373ms   & 1.3ms  & 9.5MB    & 360ms      & 0ms       & crystal 1.11.2 \\
            nim     & 1.nim   & 389ms   & 2.4ms  & 4.8MB    & 377ms      & 0ms       & nim/clang 2.0.2 \\
            nim     & 1.nim   & 577ms   & 3.8ms  & 4.5MB    & 563ms      & 0ms       & nim 2.0.2 \\
            csharp  & 2.cs    & 666ms   & 69ms 	 & 209.7MB  & 540ms      & 90ms      & dotnet 8.0.101 \\
            wasm    & 8.rs    & 864ms   & 2.7ms  & 21.8MB   & 850ms      & 0ms       & wasmtime 17.0.0 \\
            wasm    & 8.rs    & 1081ms  & 21ms 	 & 54.1MB   & 1067ms     & 13ms      & node 18.19.0 \\
            java    & 1b.java & 1159ms  & 6.4ms  & 54.5MB   & 1263ms     & 30ms      & openjdk 21 \\
            java    & 1b.java & 1160ms  & 10ms 	 & 54.8MB   & 1273ms     & 23ms      & openjdk 23 \\
            java    & 1b.java & 1196ms  & 32ms 	 & 107.7MB  & 1377ms     & 40ms      & graal/jvm 17.0.8 \\
            java    & 1.java  & 1255ms  & 1.2ms  & 131.4MB  & 1353ms     & 53ms      & graal/jvm 17.0.8 \\
            java    & 1b.java & 1269ms  & 25ms 	 & 52.8MB   & 1257ms     & 137ms     & openjdk/zgc 21 \\
            odin    & 1.odin  & 1571ms  & 1.6ms  & 4.6MB    & 1560ms     & 0ms       & odin 2024 \\
            java    & 1a.java & 1650ms  & 5.1ms  & 54.9MB   & 1750ms     & 20ms      & openjdk 21 \\
            java    & 1a.java & 1665ms  & 3.7ms  & 54.7MB   & 1760ms     & 17ms      & openjdk 23 \\
            java    & 1a.java & 1686ms  & 18ms 	 & 103.8MB  & 1813ms     & 33ms      & graal/jvm 17.0.8 \\
            java    & 1.java  & 1695ms  & 6.4ms  & 202.3MB  & 1747ms     & 60ms      & openjdk 23 \\
            java    & 1.java  & 1697ms  & 4.4ms  & 258.0MB  & 1760ms     & 47ms      & openjdk 21 \\
            java    & 1a.java & 1768ms  & 4.0ms  & 51.7MB   & 1740ms     & 143ms     & openjdk/zgc 21 \\
            csharp  & 1.cs    & 2059ms  & 1.7ms  & 42.1MB   & 2023ms     & 10ms      & dotnet 8.0.101 \\
            d       & 1.d     & 2117ms  & 11ms 	 & 9.0MB    & 2103ms     & 0ms       & dmd 2.106.1 \\
            java    & 1.java  & 2356ms  & 6.1ms  & 864.1MB  & 1797ms     & 667ms     & openjdk/zgc 21 \\
            csharp  & 3.cs    & 2491ms  & 24ms 	 & 42.5MB   & 2443ms     & 20ms      & dotnet 8.0.101 \\
            csharp  & 3.cs    & 2491ms  & 7.0ms  & 22.6MB   & 2487ms     & 0ms       & dotnet/aot 8.0.101 \\
            go      & 1.go    & 3215ms  & 5.5ms  & 7.3MB    & 3203ms     & 3ms       & go 1.21.6 \\
            csharp  & 1.cs    & 3587ms  & 56ms 	 & 22.7MB   & 3583ms     & 0ms       & dotnet/aot 8.0.101 \\
            go      & 1.go    & 4022ms  & 4.0ms  & 5.8MB    & 4013ms     & 0ms       & tinygo 0.30.0 \\
            csharp  & 1.cs    & timeout & 0.0ms  & 25.1MB   & 4980ms     & 3ms       & mono 6.12.0 \\
            java    & 2.java  & timeout & 0.0ms  & 662.0MB  & 5350ms     & 123ms     & openjdk 21 \\
            java    & 2.java  & timeout & 0.0ms  & 718.8MB  & 5263ms     & 137ms     & openjdk 23 \\
            java    & 2.java  & timeout & 0.0ms  & 3397.0MB & 3463ms     & 1890ms    & openjdk/zgc 21  \\
            \hline
        \end{tabular}
    }
    \caption{Tiempo de ejecución del computo del conjunto de Mandelbrot \cite{languagebench}}
    \label{table:languagebench}
\end{table}

\subsection{TShark}

TShark es un analizador de protocolos de red \cite{tsharkmanual}. Permite capturar datos de la red o leer paquetes de un archivo de captura. Así como Wireshark \cite{wsharkmanual}, es capaz de leer una gran cantidad de formatos y protocolos. Además, a partir de una captura finalizada, puede calcular estadísticas sobre el tráfico capturado a través del parámetro "-z". Hay muchas opciones de generación de estadísticas, algunas que podrían ser relevantes son:

\begin{enumerate} 
    \item \textbf{-z conv,type[,filter]}: Genera una tabla que lista todas las conversaciones que se han detectado en la captura. "type" indica el tipo de conversación, la cual puede ser tanto por direcciones de acceso a la red (Bluetooth, Ethernet, ...) como de red o transporte (ip, tcp, udp, ...). Cada conversación es mostrada en una fila de la tabla, la cual muestra, en número de tramas/bytes transmitidos en cada dirección, en número total, el tiempo relativo de inicio y la duración.
    \item \textbf{-z dests,tree[,filter]}: Genera estadísticas por direcciones ipv4, transporte tcp/udp y/o puerto asociado. Da información del número de transmisiones por cada uno y la cadencia
    \item \textbf{-z endpoints,type[,filter]}: Genera una tabla por cada dirección del tipo seleccionado con información sobre el número de paquetes y bytes totales, recibidos y enviados.
    \item \textbf{-z flow,name,mode[,filter]}: Muestra un diagrama de los flujos de datos en ASCII
    \item \textbf{-z icmp,srt[,filter]}: Muestra información sobre peticiones, respuestas, perdidas y latencias de peticiones ICMP eco
    \item \textbf{-z io,phs[,filter]}: Muestra un árbol con los protocolos utilizados y la cantidad respectiva de tramas/bytes que los lleva.
    \item \textbf{-z io,stat,interval[,filter][,filter][,filter]…​}: Muestra, por cada incremento del intervalo especificado, el número de tramas y bytes. 
    \item \textbf{-z io,stat,interval,"COUNT|SUM|MIN|MAX|AVG|LOAD(field)filter"}: Permite generar el número, suma, mínimo, máximo, media o proporción de cada campo en el intervalo especificado. Adicionalmente, se puede pedir el número de tramas y bytes como en la opción anterior con "FRAMES()" o "BYTES()"
    \item \textbf{-z ip\_hosts,tree[,filter]}: Genera información como con dests, pero solo de direcciones IPv4.
    \item \textbf{-z ip\_srcdst,tree[,filter]}: Genera información como con ip\_hosts, pero diferenciando direcciones IP de origen y de destino.
    \item \textbf{-z plen,tree[,filter]}: Genera estadísticas sobre los tamaños de los paquetes. Por cada grupo, se indica el número, el tamaño medio, el valor mínimo, el valor máximo y la cadencia
    \item \textbf{-z proto,colinfo,filter,field}: Utilizado para mostrar por el canal estándard información adicional sobre los campos de cada paquete
    \item \textbf{-z ptype,tree[,filter]}: Genera estadísticas sobre los protocolos utilizados en paquetes IPv4
\end{enumerate}

Pese a esto, el programa no está diseñado para la generación de estadísticas en tiempo real. Su principal objetivo es el de permitir a un operador de una red o desarrolladores de aplicaciones ver lo que está ocurriendo en la red con facilidad. La documentación del programa es útil para poder tener mayor información de lo que está ocurriendo en un momento dado de la red, pero el programa no está pensado para el propósito de generar estadísticas de los flujos en tiempo real \cite{wiresharkrealtimestats}. Lo podemos ver en el hecho de que las estadísticas se proporcionen al final, como resumen, y no se generen en cuanto los datos se encuentran disponibles.

\subsection{Zeek}

Zeek es un analizador de tráfico de red pasivo, de código abierto \cite{zeek_documentation}. Según la documentación, muchos operadores utilizan Zeek como herramienta de monitorización de la seguridad de la red. Es capaz de generar información comprensiva de todas las conexiones detectadas y de incluir metadatos de la actividad de la capa de aplicación. Ejemplos mostrados consisten en peticiones relativas a sesiones HTTP, DNS, entre otros. Además, Zeek es capaz de exportar estos datos a archivos JSON o tabulares para el postproceso de software externo o incluso escribir a bases de datos directamente. 

Otras ventajas de Zeek consisten en su capacidad de ser fácilmente escalable para tratar tráfico de alto ancho de banda y la posibilidad de personalizar su funcionamiento a través de un lenguaje específico desarrollado para este. De esta manera, Zeek aparte de soportar la detección de intrusiones a través de firmas, es capaz de ofrecer detección de anomalías y análisis de comportamiento.

Adicionalmente, existe un proyecto llamado Zeek FlowMeter el cual generara las mismas características que CICFlowMeter, pero a través de un script en Zeek \cite{zeek_flowmeter}. El código es interpretado, pero una de las mejoras propuestas en el repositorio es compilar parte de este para acelerar el proceso. Otro punto relevante es la mención de que Zeek, al ejecutar por defecto en un hilo del procesador, no hace uso extensivo de la capacidad del sistema. La mejora propuesta es hacer un Zeek Cluster \cite{zeek_documentation_cluster} para poder utilizar la capacidad de procesamiento disponible. Sin embargo, esto puede llegar a introducir una mayor complejidad al sistema.

Según la investigación realizada, no parece existir una manera oficial para utilizar Zeek como una librería dentro de otro programa o hacer uso de memoria compartida. El software está diseñado para ser ejecutado de manera independiente y compartir información con otros a través de diferentes tipos de archivos de registros \cite{zeek_documentation_logging} y conexiones utilizando la red \cite{zeek_documentation_logwriters}. De esta manera, para hacer uso de los registros generados en algoritmos de \gls{ml}, es necesario pasar por varias capas de traducción en vez de generar directamente los datos en el formato necesario.

\subsection{nprobe}

a
